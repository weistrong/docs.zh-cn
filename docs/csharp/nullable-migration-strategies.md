---
title: 升级代码库，以使用可为 null 引用类型
description: 选择升级代码库以使用可为 null 引用类型的最佳策略。
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2020
ms.locfileid: "97866819"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>更新库以使用可为 null 引用类型，并将可为空规则传达给调用方

添加[可为 null 引用类型](nullable-references.md)意味着可以声明是否允许或希望每个变量使用 `null` 值。 此外，还可应用多个属性（`AllowNull`、`DisallowNull`、`MaybeNull`、`NotNull`、`NotNullWhen`、`MaybeNullWhen` 和 `NotNullIfNotNull`），以完整描述参数和返回值的 null 状态。 这可为你提供良好的代码编写体验。 如果将不可为 null 的变量设置为 `null`，你会收到警告。 如果未对可为 null 的变量执行 null 检查就对其取消引用，你会收到警告。 更新库可能需要一些时间，但回报是值得的。 向编译器提供的有关何时允许或禁止 `null` 值的信息越多，API 用户收到的警告就越详细。 首先，让我们看一个熟悉的示例。 假设你的库具有以下用于检索资源字符串的 API：

```csharp
bool TryGetMessage(string key, out string message)
```

前面的示例遵循 .NET 中熟悉的 `Try*` 模式。 此 API 有两个引用参数：`key` 和 `message` 参数。 此 API 具有与这些参数的是否为 null 相关的以下规则：

- 调用方不应将 `null` 作为 `key` 的参数传递。
- 调用方可以传递值为 `null` 的变量作为 `message` 的参数。
- 如果 `TryGetMessage` 方法返回 `true`，则 `message` 的值不为 null。 如果返回值是 `false,`，则 `message`（及其 null 状态）的值为 null。

`key` 的规则完全可以用变量类型表示：`key` 应是不可为 null 引用类型。 `message` 参数更复杂。 它允许 `null` 作为参数，但保证成功时，`out` 参数不为 null。 对于这些情况，需要使用更丰富的词汇来描述期望。

更新库以使用可为 null 引用需要的不仅仅是在一些变量和类型名称上添加 `?`。 前面的示例表明你还需要检查 API，并考虑对每个输入参数的预期。 考虑对返回值的保证，以及方法返回时的任何 `out` 或 `ref` 参数。 然后，将这些规则传达给编译器，当调用方不遵守这些规则时，编译器将发出警告。

这项工作需要一些时间。 首先从策略入手，将库或应用程序设置为可识别可为 null 引用类型，同时均衡其他需求。 你将了解如何均衡正在进行的开发，以启用可为 null 引用类型。 你将了解泛型类型定义的相关挑战。 你将了解如何应用属性来描述各 API 的前置条件和后置条件。

## <a name="choose-a-strategy-for-nullable-reference-types"></a>选择用于可为 null 引用类型的策略

第一种选择是，默认应启用还是禁用可为 null 引用类型。 有两种策略：

- 对整个项目启用可为 null 引用类型，而在尚未就绪的代码中禁用。
- 仅对带有可为 null 引用类型注释的代码启用可为 null 引用类型。

通过向库添加其他功能而将库更新为使用可为 null 引用类型时，第一种策略最有效。 所有新开发都可识别可为 null 引用类型。 更新现有代码时，在这些类中启用可为 null 引用类型。

按照第一种策略，须执行以下步骤：

1. 将 `<Nullable>enable</Nullable>` 元素添加到 .csproj 文件，对整个项目启用可为 null 引用类型。
1. 将 `#nullable disable` pragma 添加到项目中的每个源文件。
1. 处理每个文件时，请删除 pragma 并解决所有警告。

第一种策略在将 pragma 添加到每个文件中时，需要的前期工作更多。 优点在于，添加到项目的每个新代码文件都支持可为 null 引用类型。 任何新的代码都可识别可为 null 引用类型；只须更新现有代码。

如果库稳定并且开发重点是采用可为 null 引用类型，则第二种策略效果更好。 在你注释 API 时，将启用可为 null 引用类型。 完成后，将对整个项目启用可为 null 引用类型。

按照第二种策略，须执行以下步骤：

1. 将 `#nullable enable` pragma 添加到你希望将其设置为可识别可为 null 引用类型的文件。
1. 解决任何警告。
1. 继续执行前两个步骤，直到将整个库都设置为可识别可为 null 引用类型。
1. 将 `<Nullable>enable</Nullable>` 元素添加到 csproj 文件，对整个项目启用可为 null 引用类型。
1. 当不再需要可为 null 引用类型时，删除 `#nullable enable` pragma。

第二种策略所需的前期工作较少。 缺点在于，创建新文件时的第一项任务是添加 pragma，并将文件设置为可识别可为 null 引用类型。 如果团队中任何开发人员忘记了这一点，则需要将所有代码设置为可识别可为 null 引用类型，这样，新代码现将变为积压工作 (backlog)。

选择哪种策略取决于项目中正在进行多少项活动开发。 项目越成熟稳定，第二种策略的效果越好。 开发的功能越多，第一种策略的效果越好。

> [!IMPORTANT]
> 全局可为空上下文不适用于生成的代码文件。 在这两种策略下，都会针对标记为“已生成”的任何源文件禁用可为空上下文。 这意味着生成的文件中的所有 API 都没有批注。 可采用四种方法将文件标记为“已生成”：
>
> 1. 在 .editorconfig 中，在应用于该文件的部分中指定 `generated_code = true`。
> 1. 将 `<auto-generated>` 或 `<auto-generated/>` 放在文件顶部的注释中。 它可以位于该注释中的任意行上，但注释块必须是该文件中的第一个元素。
> 1. 文件名以 TemporaryGeneratedFile_ 开头
> 1. 文件名用以 .designer.cs、.generated.cs、.g.cs 或 .g.i.cs 结尾   。
>
> 生成器可以选择使用 [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) 预处理器指令。

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>是否应为可为 null 警告引入中断性变更？

启用可为 null 引用类型之前，变量被视作“忽略可为 null”。 启用可为 null 引用类型后，这些变量变为“不可为 null”。 如果这些变量未初始化为非 null 值，编译器将发出警告。

另一个可能的警告来源是尚未初始化的返回值。

解决编译器警告的第一步是在参数和返回类型上使用 `?` 注释，以指示参数或返回值何时可能为 null。 当引用变量不得为 null 时，最初的声明正确。 执行此任务时，目标不只是修复警告。 更重要的目标是让编译器了解潜在 null 值的意图。 检查警告时，你将面临关于库的下一个重要决定。 是否考虑修改 API 签名，以便更清晰地传达设计意图？ 对于之前检查的 `TryGetMessage` 方法，更好的 API 签名可能是：

```csharp
string? TryGetMessage(string key);
```

返回值指示成功或失败，如果找到值，将包含该值。 在许多情况下，更改 API 签名可改善它们传递 null 值的方式。

但对于公共库或用户群较大的库，你可能不想引入任何 API 签名更改。 对于这类情况和其他常见情形，可以应用属性来更清楚地定义参数或返回值何时可能为 `null`。 无论是否考虑更改 API 的图面，你都可能会发现，仅使用类型注释不足以描述参数或返回值的 `null` 值。 在这些情况下，可应用属性来更清晰地描述 API。

## <a name="attributes-extend-type-annotations"></a>特性扩展类型注释

为表示有关变量的 null 状态的附加信息，已添加多个特性。 在 C# 8 引入可为 null 的引用类型之前编写的所有代码都是忽略 null 的  。 这意味着任何引用类型变量都可以为 null，但不需要进行 null 检查。 代码“可识别为 null”后，这些规则就会改变  。 引用类型不应该是 `null` 值，在取消引用之前，必须对照 `null` 检查可为 null 的引用类型。

API 的规则可能更复杂，正如你在 `TryGetValue` API 方案中看到的那样。 许多 API 对于变量何时可以或不可以为 `null` 有更复杂的规则。 在这些情况下，可使用属性来表示这些规则。 你可以在[影响可为 null 分析的属性](./language-reference/attributes/nullable-analysis.md)一文中找到描述 API 语义的属性。

## <a name="generic-definitions-and-nullability"></a>泛型定义和可为 null 性

正确传达泛型类型和泛型方法的 null 状态时，必须格外小心。 还需要额外注意，可为 null 值类型和可为 null 引用类型在本质上有所不同。 `int?` 是 `Nullable<int>` 的同义词，而 `string?` 是带有编译器添加的属性的 `string`。 因此，如果不知道 `T` 是 `class` 还是 `struct`，编译器就无法为 `T?` 生成正确的代码。

这一事实不意味着不能使用可为 null 类型（值类型或引用类型）作为封闭式泛型类型的类型参数。 `List<string?>` 和 `List<int?>` 都是 `List<T>` 的有效实例化。

它的意思是，如果没有约束，就无法在泛型类或方法声明中使用 `T?`。 例如，<xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> 将不会被更改为返回 `T?`。 你可以通过添加 `struct` 或 `class` 约束来克服此限制。 使用上述任一约束，编译器都知道如何为 `T` 和 `T?` 生成代码。

你可能想要将用于某一泛型类型参数的类型限制为不可为 null 类型。 通过在该类型参数上添加 `notnull` 约束即可实现此目的。 应用该约束后，类型参数将不得为可为 null 类型。

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a>延迟初始化属性、数据传输对象和可为 null 性

指示延迟初始化属性（即在构造后设置）的可为 null 性时，可能需要格外注意，以确保类继续正确地表达最初的设计意图。

包含延迟初始化属性的类型（例如数据传输对象 (DTO)）通常由外部库进行实例化，例如数据库 ORM（对象关系映射器）、反序列化程序或其他自动填充来自其他源的属性的组件。

在启用可为 null 引用类型之前，请考虑以下 DTO 类（代表学生）：

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

设计意图（在此例中由 `Required` 属性指示）表明，在此系统中 `FirstName` 和 `LastName` 属性是必需属性，因此不可为 null。

`VehicleRegistration` 属性不是必需属性，因此可能为 null。

启用可为 null 引用类型时，需要指出 DTO 上哪些属性可为 null，这应与最初的意图一致：

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

对于此 DTO，可能为 null 的属性只有 ``VehicleRegistration``。

但是，编译器会针对 `FirstName` 和 `LastName` 发出 `CS8618` 警告，指示不可为 null 属性未进行初始化。

你可以通过三个方法在保持最初意图的同时解决编译器警告。 这些方法均有效；你应选择最适合自己编码风格和设计要求的方法。

### <a name="initialize-in-the-constructor"></a>在构造函数中进行初始化

解决未初始化警告的理想方法是在构造函数中初始化相应属性：

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

仅当用于实例化类的库支持在构造函数中传递参数时，此方法才有效。

库可能支持在构造函数中传递某些属性，但不是全部属性。 例如，EF Core 对普通列属性支持[构造函数绑定](/ef/core/modeling/constructors)，但对导航属性却不支持。

查看有关实例化类的库的文档，了解库对构造函数绑定的支持范围。

### <a name="property-with-nullable-backing-field"></a>使用带可为 null 支持字段的属性

如果构造函数绑定不起作用，处理此问题的一种方法是使用带可为 null 支持字段的不可为 null 属性：

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

在这种情况下，如果在初始化 `FirstName` 属性之前访问该属性，则代码将引发 `InvalidOperationException`，因为错误使用了 API 协定。

注意，使用支持字段时，某些库可能有特殊的注意事项。 例如，可能需要配置 EF Core 才能正确使用[支持字段](/ef/core/modeling/backing-field)。

### <a name="initialize-the-property-to-null"></a>将属性初始化为 null

作为使用可为 null 支持字段的一种更简洁替代方法，或者在实例化类的库不适合该方法的情况下，可以在 null 包容运算符 (`!`) 的帮助下将属性直接初始化为 `null`：

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

如果还未正确初始化属性就对其进行访问，那么在运行时绝不会看到实际的 null 值（除非编程 bug 导致出现此结果）。

## <a name="see-also"></a>另请参阅

- [将现有代码库迁移到可为空引用](tutorials/upgrade-to-nullable-references.md)
- [在 EF Core 中使用可为 null 引用类型](/ef/core/miscellaneous/nullable-reference-types)
