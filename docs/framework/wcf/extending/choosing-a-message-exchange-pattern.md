---
description: 了解详细信息：选择消息交换模式
title: 选择消息交换模式
ms.date: 03/30/2017
ms.assetid: 0f502ca1-6a8e-4607-ba15-59198c0e6146
ms.openlocfilehash: c452a65e4d4108123deaab93be9bd825127eba70
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/06/2021
ms.locfileid: "99685850"
---
# <a name="choosing-a-message-exchange-pattern"></a><span data-ttu-id="b0cb8-103">选择消息交换模式</span><span class="sxs-lookup"><span data-stu-id="b0cb8-103">Choosing a Message Exchange Pattern</span></span>

<span data-ttu-id="b0cb8-104">编写自定义传输的第一步是确定正在开发的通道需要 (或 Mep) 哪些 *消息交换模式* 。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-104">The first step in writing a custom transport is to decide which *message exchange patterns* (or MEPs) are required for the channel you are developing.</span></span> <span data-ttu-id="b0cb8-105">本主题说明可用的选项，并讨论各种不同的需求。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-105">This topic describes the options available and discusses the various requirements.</span></span> <span data-ttu-id="b0cb8-106">这是 [开发渠道](developing-channels.md)中所述的通道开发任务列表中的第一个任务。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-106">This is the first task in the channel development task list described in [Developing Channels](developing-channels.md).</span></span>  
  
## <a name="six-message-exchange-patterns"></a><span data-ttu-id="b0cb8-107">六种消息交换模式</span><span class="sxs-lookup"><span data-stu-id="b0cb8-107">Six Message Exchange Patterns</span></span>  

 <span data-ttu-id="b0cb8-108">有三种 MEP 可供选择：</span><span class="sxs-lookup"><span data-stu-id="b0cb8-108">There are three MEPs to choose from:</span></span>  
  
- <span data-ttu-id="b0cb8-109">数据报（<xref:System.ServiceModel.Channels.IInputChannel> 和 <xref:System.ServiceModel.Channels.IOutputChannel>）</span><span class="sxs-lookup"><span data-stu-id="b0cb8-109">Datagram (<xref:System.ServiceModel.Channels.IInputChannel> and <xref:System.ServiceModel.Channels.IOutputChannel>)</span></span>  
  
     <span data-ttu-id="b0cb8-110">使用数据报 MEP 时，客户端将使用火灾发送消息 *并忘记* 交换。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-110">When using a datagram MEP, a client sends a message using a *fire and forget* exchange.</span></span> <span data-ttu-id="b0cb8-111">“发后不理”交换形式是一种要求带外确认成功传递的交换形式。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-111">A fire and forget exchange is one that requires out-of-band confirmation of successful delivery.</span></span> <span data-ttu-id="b0cb8-112">消息在传输过程中可能会丢失，而永远不能到达服务。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-112">The message might be lost in transit and never reach the service.</span></span> <span data-ttu-id="b0cb8-113">如果在客户端成功完成发送操作，这并不保证远程终结点已经收到消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-113">If the send operation completes successfully at the client end, it does not guarantee that the remote endpoint has received the message.</span></span> <span data-ttu-id="b0cb8-114">数据报是消息传递的基本构造块，因为您可以在它上面构建自己的协议，包括可靠的协议和安全的协议。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-114">The datagram is a fundamental building block for messaging, as you can build your own protocols on top of it—including reliable protocols and secure protocols.</span></span> <span data-ttu-id="b0cb8-115">客户端数据报通道实现 <xref:System.ServiceModel.Channels.IOutputChannel> 接口，而服务数据报通道实现 <xref:System.ServiceModel.Channels.IInputChannel> 接口。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-115">Client datagram channels implement the <xref:System.ServiceModel.Channels.IOutputChannel> interface and service datagram channels implement the <xref:System.ServiceModel.Channels.IInputChannel> interface.</span></span>  
  
- <span data-ttu-id="b0cb8-116">请求-响应（<xref:System.ServiceModel.Channels.IRequestChannel> 和 <xref:System.ServiceModel.Channels.IReplyChannel>）</span><span class="sxs-lookup"><span data-stu-id="b0cb8-116">Request-Response (<xref:System.ServiceModel.Channels.IRequestChannel> and <xref:System.ServiceModel.Channels.IReplyChannel>)</span></span>  
  
     <span data-ttu-id="b0cb8-117">在此 MEP 中，将发送一个消息并接收一个答复。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-117">In this MEP, a message is sent, and a reply is received.</span></span> <span data-ttu-id="b0cb8-118">此模式由请求-响应对组成。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-118">The pattern consists of request-response pairs.</span></span> <span data-ttu-id="b0cb8-119">请求-响应调用的示例包括远程过程调用 (RPC) 和浏览器的 GET 请求。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-119">Examples of request-response calls are remote procedure calls (RPC) and browser GET requests.</span></span> <span data-ttu-id="b0cb8-120">此模式也称为半双工。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-120">This pattern is also known as half-duplex.</span></span> <span data-ttu-id="b0cb8-121">在此 MEP 中，客户端通道实现 <xref:System.ServiceModel.Channels.IRequestChannel>，而服务通道实现 <xref:System.ServiceModel.Channels.IReplyChannel>。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-121">In this MEP, client channels implement <xref:System.ServiceModel.Channels.IRequestChannel> and service channels implement <xref:System.ServiceModel.Channels.IReplyChannel>.</span></span>  
  
- <span data-ttu-id="b0cb8-122">双工 (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span><span class="sxs-lookup"><span data-stu-id="b0cb8-122">Duplex (<xref:System.ServiceModel.Channels.IDuplexChannel>)</span></span>  
  
     <span data-ttu-id="b0cb8-123">通过双工 MEP，客户端可以发送任意数目的消息，并以任意顺序接收消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-123">The duplex MEP allows an arbitrary number of messages to be sent by a client and received in any order.</span></span> <span data-ttu-id="b0cb8-124">双工 MEP 就像电话通话，所说的每一个字都是一条消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-124">The duplex MEP is like a phone conversation, where each word being spoken is a message.</span></span> <span data-ttu-id="b0cb8-125">由于在这种 MEP 中两端都可发送和接收，因此，由客户端和服务通道实现的接口为 <xref:System.ServiceModel.Channels.IDuplexChannel>。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-125">Because both sides can send and receive in this MEP, the interface implemented by the client and service channels is <xref:System.ServiceModel.Channels.IDuplexChannel>.</span></span>  
  
 <span data-ttu-id="b0cb8-126">![选择消息交换模式](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span><span class="sxs-lookup"><span data-stu-id="b0cb8-126">![Choosing a message exchange pattern](./media/wcfc-basicthreemepsc.gif "wcfc_BasicThreeMEPsc")</span></span>  
<span data-ttu-id="b0cb8-127">三种基本的消息交换模式。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-127">The three basic message exchange patterns.</span></span> <span data-ttu-id="b0cb8-128">从上到下：数据报、请求-响应和双工。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-128">Top to bottom: datagram, request-response, and duplex.</span></span>  
  
 <span data-ttu-id="b0cb8-129">其中每个 Mep 还可以支持 *会话*。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-129">Each of these MEPs can also support *sessions*.</span></span> <span data-ttu-id="b0cb8-130">会话（和 类型的 的实现）会将通道上发送和接收的所有消息关联在一起。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-130">A session (and implementation of <xref:System.ServiceModel.Channels.ISessionChannel%601?displayProperty=nameWithType> of type <xref:System.ServiceModel.Channels.ISession?displayProperty=nameWithType>) correlates all messages sent and received on a channel.</span></span> <span data-ttu-id="b0cb8-131">请求-响应模式是一种由两个消息组成的独立会话，因为请求和响应是相关的。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-131">The request-response pattern is a stand-alone two-message session, as the request and reply are correlated.</span></span> <span data-ttu-id="b0cb8-132">与此形成对照的是，支持会话的请求-响应模式意味着该通道上的所有请求-响应对都是相关的。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-132">In contrast, the request-response pattern that supports sessions implies that all request/response pairs on that channel are correlated with each other.</span></span> <span data-ttu-id="b0cb8-133">这使您总共有六种 MEP 可以选择：</span><span class="sxs-lookup"><span data-stu-id="b0cb8-133">This gives you a total of six MEPs to choose from:</span></span>  
  
- <span data-ttu-id="b0cb8-134">数据报</span><span class="sxs-lookup"><span data-stu-id="b0cb8-134">Datagram</span></span>  
  
- <span data-ttu-id="b0cb8-135">请求-响应</span><span class="sxs-lookup"><span data-stu-id="b0cb8-135">Request-response</span></span>  
  
- <span data-ttu-id="b0cb8-136">双工</span><span class="sxs-lookup"><span data-stu-id="b0cb8-136">Duplex</span></span>  
  
- <span data-ttu-id="b0cb8-137">带会话的数据报</span><span class="sxs-lookup"><span data-stu-id="b0cb8-137">Datagram with sessions</span></span>  
  
- <span data-ttu-id="b0cb8-138">带会话的请求-响应</span><span class="sxs-lookup"><span data-stu-id="b0cb8-138">Request-response with sessions</span></span>  
  
- <span data-ttu-id="b0cb8-139">带会话的双工</span><span class="sxs-lookup"><span data-stu-id="b0cb8-139">Duplex with sessions</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b0cb8-140">对于 UDP 传输，所支持的唯一 MEP 是数据报，因为 UDP 的性质是一个“启动后不管”协议。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-140">For the UDP transport, the only MEP that is supported is datagram, because UDP is inherently a fire and forget protocol.</span></span>  
  
## <a name="sessions-and-sessionful-channels"></a><span data-ttu-id="b0cb8-141">会话和会话通道</span><span class="sxs-lookup"><span data-stu-id="b0cb8-141">Sessions and Sessionful Channels</span></span>  

 <span data-ttu-id="b0cb8-142">在网络世界中，有面向连接的协议（例如 TCP）和无连接的协议（例如 UDP）。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-142">In the networking world, there are connection-oriented protocols (for example, TCP) and connection-less protocols (for example, UDP).</span></span> <span data-ttu-id="b0cb8-143">WCF 使用字词会话表示类似连接的逻辑抽象。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-143">WCF uses the term session to mean a connection-like logical abstraction.</span></span> <span data-ttu-id="b0cb8-144">会话 WCF 协议类似于面向连接的网络协议，而无会话 WCF 协议则类似于无连接的网络协议。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-144">Sessionful WCF protocols are similar to connection-oriented network protocols and sessionless WCF protocols are similar to connection-less network protocols.</span></span>  
  
 <span data-ttu-id="b0cb8-145">在通道目标模型中，每个逻辑会话都表现为一个会话通道的实例。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-145">In the channel object model, each logical session manifests as an instance of a sessionful channel.</span></span> <span data-ttu-id="b0cb8-146">因此，由客户端创建并在服务端接受的每个新会话都与每一端的一个新会话通道相对应。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-146">Therefore every new session created by the client, and accepted on the service, corresponds to a new sessionful channel on each side.</span></span> <span data-ttu-id="b0cb8-147">下面的关系图的上部显示无会话通道的结构，下部显示会话通道的结构。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-147">The following diagram shows, on the top, the structure of sessionless channels, and on the bottom, the structure of sessionful channels.</span></span>  
  
 <span data-ttu-id="b0cb8-148">![选择消息交换模式](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span><span class="sxs-lookup"><span data-stu-id="b0cb8-148">![Choosing a message exchange pattern](./media/wcfc-sessionandsessionlesschannelsc.gif "wcfc_SessionAndSessionlessChannelsc")</span></span>  
  
 <span data-ttu-id="b0cb8-149">客户端创建新的会话通道并发送消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-149">A client creates a new sessionful channel and sends a message.</span></span> <span data-ttu-id="b0cb8-150">在服务端，通道侦听器收到此消息并检测到它属于新会话，于是就创建新的会话通道，并将其交给应用程序（以响应在通道侦听器上调用 AcceptChannel 的应用程序）。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-150">On the service side, the channel listener receives this message and detects that it belongs to a new session so it creates a new sessionful channel and hands it to the application (in response to the application calling AcceptChannel on the channel listener).</span></span> <span data-ttu-id="b0cb8-151">然后应用程序会收到此消息，以及通过同一个会话通道在同一个会话中发送的所有后续消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-151">The application then receives this message and all subsequent messages sent in the same session through the same sessionful channel.</span></span>  
  
 <span data-ttu-id="b0cb8-152">另一个客户端（或同一个客户端）创建新的会话通道并发送消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-152">Another client (or the same client) creates a new sessionful and sends a message.</span></span> <span data-ttu-id="b0cb8-153">通道侦听器检测到此消息属于新的会话，于是便创建新会话通道；此过程不断重复。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-153">The channel listener detects this message is in a new session and creates a new sessionful channel and the process repeats.</span></span>  
  
 <span data-ttu-id="b0cb8-154">没有会话，就没有通道和会话之间的相关性。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-154">Without sessions, there is no correlation between channels and sessions.</span></span> <span data-ttu-id="b0cb8-155">因此通道侦听器只创建一个通道，接收到的所有消息都通过该通道传递给应用程序。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-155">Therefore a channel listener creates only one channel through which all received messages are delivered to the application.</span></span> <span data-ttu-id="b0cb8-156">也不会有消息的排序，因为没有会话可供在其中维护消息顺序。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-156">There is also no message ordering because there is no session within which to maintain message order.</span></span> <span data-ttu-id="b0cb8-157">上图的上部描述了无会话消息交换。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-157">The top portion of the preceding graphic illustrates a sessionless message exchange.</span></span>  
  
## <a name="starting-and-terminating-sessions"></a><span data-ttu-id="b0cb8-158">开始和终止会话</span><span class="sxs-lookup"><span data-stu-id="b0cb8-158">Starting and Terminating Sessions</span></span>  

 <span data-ttu-id="b0cb8-159">只需创建一个新的会话通道，即可在客户端开始会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-159">Sessions are started on the client by simply creating a new sessionful channel.</span></span> <span data-ttu-id="b0cb8-160">当服务收到在新会话中发送的消息时，会话即在服务上开始。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-160">They are started on the service when the service receives a message that was sent in a new session.</span></span> <span data-ttu-id="b0cb8-161">同样，关闭或中止会话通道即可终止会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-161">Likewise, sessions are terminated by closing or aborting a sessionful channel.</span></span>  
  
 <span data-ttu-id="b0cb8-162">这种情况的例外是 <xref:System.ServiceModel.Channels.IDuplexSessionChannel>，它用于以双工会话通信模式发送和接收消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-162">The exception to this is <xref:System.ServiceModel.Channels.IDuplexSessionChannel> which is used for both sending and receiving messages in a duplex, sessionful communication pattern.</span></span> <span data-ttu-id="b0cb8-163">有可能一端希望停止发送消息，但是希望继续接收消息，因此在使用 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 时，有一种机制能让您关闭输出会话，显示您不再发送更多消息，但是保持输入会话打开，以允许您继续接收消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-163">It is possible that one side will want to stop sending messages but continue to receive messages therefore when using <xref:System.ServiceModel.Channels.IDuplexSessionChannel> there is a mechanism that lets you close the output session indicating you will not send any more messages but keep the input session opened allowing you to continue to receive messages.</span></span>  
  
 <span data-ttu-id="b0cb8-164">通常是在传出端关闭对话，而不在传入端关闭对话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-164">In general, sessions are closed on the outgoing side and not on the incoming side.</span></span> <span data-ttu-id="b0cb8-165">也就是说，会话输出通道可能关闭，从而完全终止会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-165">That is, sessionful output channels can be closed, thereby cleanly terminating the session.</span></span> <span data-ttu-id="b0cb8-166">关闭会话输出通道会使相应的会话输入通道向在 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上调用 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 的应用程序返回空值。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-166">Closing a sessionful output channel causes the corresponding sessionful input channel to return null to the application calling <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel>.</span></span>  
  
 <span data-ttu-id="b0cb8-167">然而会话输入通道不应该关闭，除非 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 返回空值，指示该会话已经关闭。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-167">However sessionful input channels should not be closed unless <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> returns null, indicating that the session is already closed.</span></span> <span data-ttu-id="b0cb8-168">如果 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上的 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 没有返回空值，则关闭会话输入通道可能引发异常，因为当通道关闭时可能收到意外的消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-168">If <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> on the <xref:System.ServiceModel.Channels.IDuplexSessionChannel> has not returned null, closing a sessionful input channel may throw an exception because it may receive unexpected messages while closing.</span></span> <span data-ttu-id="b0cb8-169">如果在发送方终止会话之前接收方希望终止会话，接收方应该在输入通道上调用 <xref:System.ServiceModel.ICommunicationObject.Abort%2A>，这可以突然终止会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-169">If a receiver wishes to terminate a session before the sender does, it should call <xref:System.ServiceModel.ICommunicationObject.Abort%2A> on the input channel, which abruptly terminates the session.</span></span>  
  
## <a name="writing-sessionful-channels"></a><span data-ttu-id="b0cb8-170">编写会话通道</span><span class="sxs-lookup"><span data-stu-id="b0cb8-170">Writing Sessionful Channels</span></span>  

 <span data-ttu-id="b0cb8-171">作为会话通道作者，有几件事是您的通道为了提供会话所必须做的。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-171">As a sessionful channel author, there are a few things your channel must do to provide sessions.</span></span> <span data-ttu-id="b0cb8-172">在发送端，您的通道需要：</span><span class="sxs-lookup"><span data-stu-id="b0cb8-172">On the send side, your channel needs to:</span></span>  
  
- <span data-ttu-id="b0cb8-173">为每个新通道创建一个新会话，并将其与一个新的会话标识关联，该标识是一个唯一的字符串。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-173">For each new channel, create a new session and associate it with a new session id which is a unique string.</span></span> <span data-ttu-id="b0cb8-174">或者从堆栈中位于您下方的会话通道获取一个新会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-174">Or obtain a new session from the sessionful channel below you in the stack.</span></span>  
  
- <span data-ttu-id="b0cb8-175">对于用此通道发送的每条消息，如果您的通道创建了会话（而不是从您下面的层获取会话），您需要将此消息与会话关联。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-175">For each message sent using this channel, if your channel created the session (as opposed to obtaining it from the layer below you), you need to associate the message with the session.</span></span> <span data-ttu-id="b0cb8-176">对于协议通道，这通常通过添加 SOAP 标头来完成。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-176">For protocol channels, this is typically done by adding a SOAP header.</span></span> <span data-ttu-id="b0cb8-177">对于传输通道，这通常通过创建一个新的传输连接或向组帧协议添加会话信息来完成。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-177">For transport channels, this is typically done by creating a new transport connection or adding session information to the framing protocol.</span></span>  
  
- <span data-ttu-id="b0cb8-178">对于每个使用此通道发送的消息，都需要提供上面提到的传递保证。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-178">For each message sent using this channel, you need to provide the delivery guarantees mentioned above.</span></span> <span data-ttu-id="b0cb8-179">如果依靠位于您下面的通道来提供会话，该通道也应提供传递保证。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-179">If you are relying on the channel below you to provide the session, that channel will also provide the delivery guarantees.</span></span> <span data-ttu-id="b0cb8-180">如果您自己提供会话，您需要把这些保证作为您的协议的一部分加以实现。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-180">If you’re providing the session yourself, you need to implement those guarantees as part of your protocol.</span></span> <span data-ttu-id="b0cb8-181">通常，如果您编写在两端都采用 WCF 的协议通道，您可能需要 TCP 传输或可靠消息通道，并依靠其中一种方法来提供会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-181">In general, if you are writing a protocol channel that assumes WCF on both sides you may require the TCP transport or the Reliable Messaging channel and rely on either one to provide a session.</span></span>  
  
- <span data-ttu-id="b0cb8-182">当在您的通道上调用 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 时，应使用指定的或默认的超时值执行必要的工作来关闭该会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-182">When <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> is called on your channel, perform the necessary work to close the session using either the specified timeout or the default one.</span></span> <span data-ttu-id="b0cb8-183">这可能很简单，只需在位于您下面的通道上调用 <xref:System.ServiceModel.ICommunicationObject.Close%2A>（如果您只从它获取了会话）、发送特殊 SOAP 消息或关闭传输连接。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-183">This can be as simple as calling <xref:System.ServiceModel.ICommunicationObject.Close%2A> on the channel below you (if you just obtained the session from it) or sending a special SOAP message or closing a transport connection.</span></span>  
  
- <span data-ttu-id="b0cb8-184">当在您的通道上调用 <xref:System.ServiceModel.ICommunicationObject.Abort%2A> 时，应立即终止会话而不必执行 I/O。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-184">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="b0cb8-185">这可能意味着不执行任何操作，或者可能涉及中止一个网络连接或某个其他资源。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-185">This may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
 <span data-ttu-id="b0cb8-186">在接收端，您的通道需要：</span><span class="sxs-lookup"><span data-stu-id="b0cb8-186">On the receive side, your channel needs to:</span></span>  
  
- <span data-ttu-id="b0cb8-187">对于每个传入消息，通道侦听器必须检测到消息所属的会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-187">For each incoming message, the channel listener must detect the session it belongs to.</span></span> <span data-ttu-id="b0cb8-188">如果这是会话中的第一个消息，通道侦听器必须创建一个新通道，并将其从调用返回到 <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-188">If this is the first message in the session, the channel listener must create a new channel and return it from the call to <xref:System.ServiceModel.Channels.IChannelListener%601.AcceptChannel%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0cb8-189">否则，通道侦听器必须找到与该会话对应的现有通道，并通过该通道传递消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-189">Otherwise the channel listener must find the existing channel that corresponds to the session and deliver the message through that channel.</span></span>  
  
- <span data-ttu-id="b0cb8-190">如果您的通道正在提供会话（连同所要求的传递保证），可能会要求接收方执行某些操作，例如重新排列消息或发送确认消息。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-190">If your channel is providing the session (along with the required delivery guarantees) the receive side may be required to perform some actions such as re-order messages or send acknowledgements.</span></span>  
  
- <span data-ttu-id="b0cb8-191">当在您的通道上调用 <xref:System.ServiceModel.ICommunicationObject.Close%2A> 时，应使用指定的或默认的超时值执行必要的工作来关闭该会话。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-191">When <xref:System.ServiceModel.ICommunicationObject.Close%2A> is called on your channel, perform the necessary work to close the session either the specified timeout or the default one.</span></span> <span data-ttu-id="b0cb8-192">如果通道在等待关闭超时到期时收到消息，则可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-192">This could result in exceptions if the channel receives a message while waiting for the close timeout to expire.</span></span> <span data-ttu-id="b0cb8-193">这是因为通道将处于关闭状态，却突然收到消息，所以会引发异常。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-193">That’s because the channel will be in the Closing state when it receives a message so it would throw.</span></span>  
  
- <span data-ttu-id="b0cb8-194">当在您的通道上调用 <xref:System.ServiceModel.ICommunicationObject.Abort%2A> 时，应立即终止会话而不必执行 I/O。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-194">When <xref:System.ServiceModel.ICommunicationObject.Abort%2A> is called on your channel, terminate the session abruptly without performing I/O.</span></span> <span data-ttu-id="b0cb8-195">同样，这可能意味着不执行任何操作，或者可能涉及中止一个网络连接或某个其他资源。</span><span class="sxs-lookup"><span data-stu-id="b0cb8-195">Again, this may mean doing nothing or may involve aborting a network connection or some other resource.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b0cb8-196">请参阅</span><span class="sxs-lookup"><span data-stu-id="b0cb8-196">See also</span></span>

- [<span data-ttu-id="b0cb8-197">通道模型概述</span><span class="sxs-lookup"><span data-stu-id="b0cb8-197">Channel Model Overview</span></span>](channel-model-overview.md)
